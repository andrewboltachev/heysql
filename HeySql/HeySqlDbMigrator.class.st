"
This class handles the migration of the database.

Add class methods to this starting with mig_X where x is a number as we changes the databse.
"
Class {
	#name : #HeySqlDbMigrator,
	#superclass : #Object,
	#classVars : [
		'HeySqlMigrationClass'
	],
	#category : #'HeySql-Migrations'
}

{ #category : #db }
HeySqlDbMigrator class >> createMigration [
	"This creates a migration with the current time as a part of the method name, remark the underscore."

	| migrateTime method |
	HeySqlMigrationClass.
	migrateTime := self getNow.
	method := '
	   migrate_{1}
	   "HeySql autogenerated method for adding a migration. Add your code below here."
	' format: {migrateTime}.
	HeySqlMigrationClass class compile: method classified: 'db-migration'.
	^ migrateTime.
]

{ #category : #db }
HeySqlDbMigrator class >> createMigrationTemplate: packageName [
	"Based on the package name - iterate over all classes in the package and write templates for creating corresponding tb-tables, based on the instance vars. This method is just for now writing to much code when bootstrapping a project.
	Use like this: HeySqlDbMigrator createMigrationTemplate: 'Sakuraeco-Models'.
	Remark that there are no dependency analysys between the tables, so the output order of the tables is random 
	"

	| classes dbVars |
	Transcript clear.
	classes := Smalltalk allClassesAndTraits
		select: [ :theClass | 
			| className |
			className := theClass category asString.
			(className beginsWith: packageName)
				& ((className findString: 'Manifest') = 0) ].
	classes
		do: [ :c | 
			| vars table |
			Transcript
				show:
					('\\\\"-- Generated code for class: {1}"
		' format: {c asString}) withCRs.
			dbVars := c dbFields.
			vars := ((dbVars
				collect: [ :v | '         ( ''{1}'' -> ''type'')' format: {v asString} ])
				joinUsing: ' . \') withCRs.
			table := 'table := \{ \\{1} \\       \} asDictionary. \
			
	    HeySql createTable: ''{2}'' tableDict: table.
			
			'
				format:
					{vars.
					c asString}.
			Transcript show: table withCRs ]
]

{ #category : #db }
HeySqlDbMigrator class >> forceMigrateOne: methodName [
	"Note, this should be only used in special cases. It does not!! update the migration table"

	| method |
	method := ('migrate_' , methodName) asSymbol.
	self migrateSome: { method }.
]

{ #category : #private }
HeySqlDbMigrator class >> getCurrentMigrationFromDb [
	"comment stating purpose of class-side message"

	| client res |
	client := HeySql connection.
	res := (client query: 'select mdate from migrations where id = 1')
		data.
	res isEmpty
		ifTrue: [ ^ #('0') ].
	^ res at: 1
]

{ #category : #private }
HeySqlDbMigrator class >> getNow [
	"returns now in migrate format"

	^ (ZTimestamp now asString copyReplaceAll: '-' with: '_')
		copyReplaceAll: ':'
		with: '_'
]

{ #category : #db }
HeySqlDbMigrator class >> migrate [
	"migrates database up to current version."

	| start stop |
	start := (self getCurrentMigrationFromDb) at: 1.
	stop := self getNow.
	start >= stop
		ifTrue: [ ^ false ].
	self migratestart: start to: stop.
	self updateMigrationTable: stop.
	^ true
]

{ #category : #private }
HeySqlDbMigrator class >> migrateSome: migrateMethods [
	"Migrate one or many methods"

	| client |
	Transcript
		show: 'Doing migration';
		cr.
	client := HeySql connection.
	client execute: 'begin transaction'.
	[ migrateMethods asSortedCollection
		do: [ :method | HeySqlMigrationClass perform: method ] ]
		on: Exception
		do: [ :ex | 
			client execute: 'rollback'.
			ex pass ].
	client execute: 'commit;'.
	Transcript
		show: 'Done migration - success';
		cr
]

{ #category : #private }
HeySqlDbMigrator class >> migratestart: migrateStart to: migrateStop [
	"Used to run migratios. Use like this:
	DbMigrator migrate: '2019_10_06T11_15_16Z' to:  '2019_11_06T11_15_16Z'
	
	Note! Library does not check if these migrations allready has been run (will maybe be added soon)
	"

	"use this to get the instance methods: Person methodDict keys."

	| migrateMethods |
	migrateMethods := HeySqlMigrationClass class selectors
		select: [ :m | 
			| t |
			t := m asString copyFrom: 9 to: 28.
			(m asString beginsWith: 'migrate_') & (t >= migrateStart)
				& (t <= migrateStop) ].
	self migrateSome: migrateMethods
]

{ #category : #'instance creation' }
HeySqlDbMigrator class >> new: theClass [
	"constructor - call with the migration class name"
	HeySqlMigrationClass := theClass .

]

{ #category : #db }
HeySqlDbMigrator class >> updateMigrationTable: date [
	"Updates migration table with current date, creates table if needed"

	| client update |
	client := HeySql connection.
	update := 'insert into migrations(id, mdate) values (1, ''{1}'') on conflict(id) do update set mdate = ''{1}'''
		format: {date}.
	client
		execute: 'create table if not exists migrations (id serial unique, mdate text)';
		execute: update
]
