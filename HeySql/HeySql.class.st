"
""note that there is no binding between this function and rest of heysql, so can tables
	in practice be done from pure sql code as well.
	
	Dictionary should be oncreateTableCellButtonUsing: 
	colors := Dictionary personDict { 
	   'id' -> 'serial' . 
	   'forname' -> 'textt' . 
	   'surname' -> 'json' 
	}. 

	All P3-types can be used, look them up for a complete list
"
Class {
	#name : #HeySql,
	#superclass : #Object,
	#instVars : [
		'id'
	],
	#classVars : [
		'Client',
		'DbFields',
		'InsertDb',
		'Statements',
		'UpdateDb'
	],
	#category : #'HeySql-Initialize'
}

{ #category : #connection }
HeySql class >> connect: client [
	"First connect through p3 as usual, and pass the client on to this class. Reuse client if allready set"
	Client := client.
	client ifNil: [ Client := client ]
]

{ #category : #accessing }
HeySql class >> connection [
	"return the db connection"
	^ Client.

]

{ #category : #initialization }
HeySql class >> createTable: tableName tableDict: tableDict [
	"helper function to quick create table based on a heysql instance
        note that there is no binding between this function and rest of heysql, so can tables
        in practice be done from pure sql code as well.
        
        Dictionary should be oncreateTableCellButtonUsing:
        personDict := Dictionary newFrom { 
           'id' -> 'serial' .
           'forname' -> 'textt' . 
           'surname' -> 'json' 
        }.

        All P3-types can be used, look them up for a complete list"

	| sqlString |
	sqlString := 'create table {1} (' format: {tableName}.
	tableDict
		keysAndValuesDo: [ :fieldName :fieldType | 
			sqlString := sqlString , '{1} {2},'
				format:
					{fieldName.
					fieldType} ].
	Client execute: (sqlString allButLast , ')').			
]

{ #category : #accessing }
HeySql class >> dbFields [
	"returns the fields to be handled by heysql as a string. If the dbFields: function is not called, we use all instance variables from the class, including superclasses of type heysql"

	| key |
	key := self asString.
	(DbFields includesKey: key)
		ifFalse: [ | classes dbfields |
			classes := self allSuperclasses
				select: [ :c | c respondsTo: #dbFields ].
			dbfields := classes , {self}
				flatCollect: [ :c | 
					(DbFields includesKey: c asString)
						ifTrue: [ DbFields at: c asString ]
						ifFalse: [ c instVarNames collect: [ :v | v asString ] ] ].
			DbFields at: key put: dbfields asSet asSortedCollection ].
	^ DbFields at: key
]

{ #category : #accessing }
HeySql class >> dbFields: allFields [
	"Set fields which also have column in database"

	| fields |
	fields := (allFields splitOn: ' ') asSet.
	DbFields at: self asString put: fields asArray.
	self generateGettersAndSetters
]

{ #category : #connection }
HeySql class >> disConnect [
	"disConnect the db-client"
	Client close

]

{ #category : #'private ' }
HeySql class >> findNumberOfParams: sql [
	"Iterates over a P3-executable and finds number of sql-params, namely those who starts with $"

	| s |
	s := Set new.
	sql regex: '[$]\d+' matchesCollect: [ :r | s add: r ]. 
	^ s size
]

{ #category : #initialization }
HeySql class >> generateGettersAndSetters [
	"Generete getters and setters for all db-fields. Db-fields should allready be set with DbFields"

	self dbFields 
		do: [ :field | 
			| getter setter |
			getter := '
	    {1} 
	    "Autogenerated HeySql getter"
	    ^{1}.
	  ' format: {field}.
			setter := '
	    {1}: x  
	    "Autogenerated HeySql setter"
	    {1} := x.
	  ' format: {field}.
			self compile: getter classified: 'accessor'.
			self compile: setter classified: 'accessor' ]
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationInsert: tableName [
	"Generate methods for inserting and updating. Before running this method setDbFiels must have been called"

	| sqlInsert fields values method |
	fields := (self dbFields select: [ :f | f ~~ 'id' ]) joinUsing: ','.
	values := (Interval from: 1 to: (self dbFields) size)
		collect: [ :i | '$' , i asString ].
	sqlInsert := 'insert into {1}({2}) values({3}) returning id'
		format:
			{tableName.
			fields.
			(values joinUsing: ',')}.
	[ InsertDb := Client prepare: sqlInsert ]
		on: P3Error
		do: [ :e | 
			(e asString findString: 'already exists') > 0
				ifTrue: [ Transcript
						show: 'Warning only, but just to let you know: ';
						show: e asString ]
				ifFalse: [ e pass ] ].
	method := '
	   insert
	   "HeySql autogenerated method for inserting objects"
	   | values res newId |
		values := (self class dbFields) collect: [ :field |
		  self perform: (field asSymbol).
		 ].
	   res := InsertDb query: values.
	   newId := ((res data) at: 1) at: 1.
	   self id: newId.
	   ^ res. 
	'.
	self compile: method classified: 'db'
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationUpdate: tableName [
	"generate update statment and method on object"

	| sqlUpdate fields values method updateFields |
	fields := self dbFields select: [ :f | f ~~ 'id' ].
	values := (Interval from: 1 to: (self dbFields) size)
		collect: [ :i | '$' , i asString ].
	updateFields := fields with: values collect: [ :f :v | f , '=' , v ].
	sqlUpdate := 'update {1} set {2} where id = {3}'
		format:
			{tableName.
			(updateFields joinUsing: ', ').
			('$' , (fields size + 1) asString)}.
	[ UpdateDb := Client prepare: sqlUpdate ]
		on: P3Error
		do: [ :e | 
			(e asString findString: 'already exists') > 0
				ifTrue: [ Transcript
						show: 'Warning only, but just to let you know: ';
						show: e asString ]
				ifFalse: [ e pass ] ].
	method := '
	   update
	   "HeySql autogenerated method for inserting objects"
	   | values res fields id |
	   fields := (self class dbFields) select: [ :f | f ~~ ''id'' ].
		values := fields collect: [ :field |
		  self perform: (field asSymbol).
		 ].
	   id := self id.
	   res := UpdateDb query: values , {id}.
	   ^ res. 
	'.
	self compile: method classified: 'db'
]

{ #category : #initialization }
HeySql class >> generateSimpleDbOperations: tableName [
	"generate insert and update statemens and methods for the object. setDbFields must have been done before doing this."

	self generateSimpleDbOperationInsert: tableName.
	self generateSimpleDbOperationUpdate: tableName
]

{ #category : #initialization }
HeySql class >> generateSqlMethods: dict [
	"Iterating over all key-value elements in a dictionary and creates methods based on these. It is based on P3-postgres syntax.
	 sql-functions with parameter need to be declared ending with colon, like always in smalltalk "

	"Example: 
	
	d := Dictionary newFrom: 
	{ 'allBooks' -> 'select * from books' . 
  	  'allCustomerWithMoreThanOnePurches' -> 'select, join and have sql-fun here' 
	  'queryWithTwoParamsParam1, param2' -> 'select something where x = $1 and y = $2 ]  '
	}. 
	
	"

	
	dict
		keysAndValuesDo: [ :methodNames :sql | 
			"self class compile: methodString classified: 'heysql' ]"
			| methodString numParamsInSql params methodNameMaybeParams executeParams allMethods |
			self generateSqlStatement: methodNames sql: sql.
			numParamsInSql := self findNumberOfParams: sql.
			params := numParamsInSql > 0
				ifTrue: [ (Interval from: 1 to: numParamsInSql)
						collect: [ :v | 'p' , v asString ] ]
				ifFalse: [ #() ].
			methodNameMaybeParams := numParamsInSql > 0
				ifTrue: [ allMethods := (methodNames splitOn: ',') collect: [ :s | s , ': ' ].
					(allMethods with: params collect: [ :s1 :s2 | s1 , s2 ])
						joinUsing: ' ' ]
				ifFalse: methodNames.
			executeParams := '{ ' , (params joinUsing: '. ') , ' }'.
			methodString := '
	     {1} 
	     "Autogenerated heysql-method"
	     | statement result |
	     statement := Statements at: ''{3}''.
	     result := statement query: {2}. 
	
	     ^ (self toObject: result).
	    '
				format:
					{methodNameMaybeParams.
					executeParams.
					methodNames}.
			self class compile: methodString classified: 'accessor' ]
]

{ #category : #'private ' }
HeySql class >> generateSqlStatement: methodName sql: sql [
	"Add an server side compiled statment which can be access from a slot"

	| statement |
	statement := Client prepare: sql.
	Statements at: methodName put: statement
]

{ #category : #initialization }
HeySql class >> init [
	"init start variables"

	Statements := Dictionary new.
	DbFields := Dictionary new.
]

{ #category : #db }
HeySql class >> packageDbSetup: packageName [
	"Iterates over all classes in a package and calls dbSetup method on the method if found"

	| classes |
	classes := Smalltalk allClassesAndTraits
		select: [ :theClass | 
			| className |
			className := theClass category asString.
			(className beginsWith: packageName)
				& ((className findString: 'Manifest') = 0) ].
	classes
		do: [ :theClass | 
			Transcript show: theClass.
			(theClass respondsTo: #dbSetup)
				ifTrue: [ theClass dbSetup ] ]
]

{ #category : #'private ' }
HeySql class >> toObject: rSet [
	"Convert P3-result to an object. This is done by reflecion - iterating over all fields."

	| methodFields manyObjects res |
	methodFields := rSet data
		collect: [ :row | 
			(rSet descriptions collect: [ :f | f fieldName ])
				with: row
				collect: [ :f1 :f2 | 
					{f1.
					f2} ] ].
	manyObjects := methodFields
		collect: [ :row | 
			| obj |
			obj := self new.
			row
				do: [ :field | 
					obj
						perform: (field first , ':') asSymbol
						withArguments: {field second} ].
			obj ].
	res := manyObjects size > 1
		ifTrue: [ manyObjects ]
		ifFalse: [ manyObjects first ].
	^ res
]

{ #category : #accessor }
HeySql >> id [ 
	    "Autogenerated HeySql getter"
	    ^id.
	  
]

{ #category : #accessor }
HeySql >> id: x [  
	    "Autogenerated HeySql setter"
	    id := x.
	  
]

{ #category : #documenting }
HeySql >> notes [
	" 
	TEST
	myDict keysAndValuesDo: [ :key :value | value doSomething ].
	Dictionary newFrom: {1 -> 7. 2 -> 3. 3 -> 1. 4 -> 3}
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	(Smalltalk classNamed: clsName) methodName: arg. (maybe param, but check more params) 
	
	Transcript show: o class asString.
	
	'HeySql' asClass .
	
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	5 perform: ('factorial' asSymbol ) og 4 perform: #max: withArguments
	
!! Encode

x := (ZnCharacterEncoder newForEncoding: 'utf8')
      encodeString: 'Les élèves Français'.

(ZnCharacterEncoder newForEncoding: 'utf8') decodeBytes: x		
	
	"

	<wikiStyleHelp: #'The name of the book I want to write'>
	
]
