"
""note that there is no binding between this function and rest of heysql, so can tables
	in practice be done from pure sql code as well.
	
	Dictionary should be oncreateTableCellButtonUsing: 
	colors := Dictionary personDict { 
	   'id' -> 'serial' . 
	   'forname' -> 'textt' . 
	   'surname' -> 'json' 
	}. 

	All P3-types can be used, look them up for a complete list
"
Class {
	#name : #HeySql,
	#superclass : #Object,
	#instVars : [
		'id'
	],
	#classVars : [
		'Client',
		'DbFields',
		'Statements'
	],
	#category : #'HeySql-Initialize'
}

{ #category : #adding }
HeySql class >> addDependencies [
	"This load dependencies which are needed for the package to work"
	Metacello new
 	  baseline: 'P3';
	   repository: 'github://svenvc/P3';
	   load.
]

{ #category : #connection }
HeySql class >> connect: client [
	"First connect through p3 as usual, and pass the client on to this class. Reuse client if allready set"
	Client := client.
	client ifNil: [ Client := client ]
]

{ #category : #initialization }
HeySql class >> createTable: tableName tableDict: tableDict [
	"helper function to quick create table based on a heysql instance
        note that there is no binding between this function and rest of heysql, so can tables
        in practice be done from pure sql code as well.
        
        Dictionary should be oncreateTableCellButtonUsing:
        personDict := Dictionary newFrom { 
           'id' -> 'serial' .
           'forname' -> 'textt' . 
           'surname' -> 'json' 
        }.

        All P3-types can be used, look them up for a complete list"

	| sqlString |
	sqlString := 'create table {1} (' format: {tableName}.
	tableDict
		keysAndValuesDo: [ :fieldName :fieldType | 
			sqlString := sqlString , '{1} {2},'
				format:
					{fieldName.
					fieldType} ].
	Client execute: (sqlString allButLast , ')').			
]

{ #category : #initialization }
HeySql class >> findNumberOfParams: sql [
	"Iterates over a P3-executable and finds number of sql-params, namely those who starts with $"
		| s |
	s := Set new.
	sql regex: '[$]\d+' matchesCollect: [ :r |
	s add: r].
	^ (s size)
]

{ #category : #accesing }
HeySql class >> generateGettersAndSetters [
	"Generete getters and setters for all db-fields"

	DbFields
		do: [ :field | 
			| getter setter |
			getter := '
	    {1} 
	    "Autogenerated HeySql getter"
	    ^{1}.
	  ' format: {field}.
			setter := '
	    {1}: x  
	    "Autogenerated HeySql setter"
	    {1} := x.
	  ' format: {field}.
			self  compile: getter classified: 'accessor'.
			self  compile: setter classified: 'accessor' ]
]

{ #category : #initialization }
HeySql class >> generateSqlMethods: dict [
	"Iterating over all key-value elements in a dictionary and creates methods based on these. It is based on P3-postgres syntax.
	 sql-functions with parameter need to be declared ending with colon, like always in smalltalk "

	"Example: 
	
	d := Dictionary newFrom: 
	{ 'allBooks' -> 'select * from books' . 
  	  'allCustomerWithMoreThanOnePurches' -> 'select, join and have sql-fun here' 
	  'queryWithTwoParams' -> 'select something where x = $1 and y = $2 ]  '
	}. 
	
	"

	Statements := Dictionary new.
	dict
		keysAndValuesDo: [ :methodNames :sql | 
			"self class compile: methodString classified: 'heysql' ]"
			| methodString numParamsInSql params methodNameMaybeParams executeParams allMethods |
			Transcript
				show: 'Handling: ';
				show: methodNames.
			self generateSqlStatement: methodNames sql: sql.
			numParamsInSql := self findNumberOfParams: sql.
			params := numParamsInSql > 0
				ifTrue: [ (Interval from: 1 to: numParamsInSql)
						collect: [ :v | 'p' , v asString ] ]
				ifFalse: [ #() ].
			methodNameMaybeParams := numParamsInSql > 0
				ifTrue: [ allMethods := (methodNames splitOn: ',') collect: [ :s | s , ': ' ].
					(allMethods with: params collect: [ :s1 :s2 | s1 , s2 ])
						joinUsing: ' ' ]
				ifFalse: methodNames.
			executeParams := '{ ' , (params joinUsing: '. ') , ' }'.
			methodString := '
	     {1} 
	     "Autogenerated heysql-method"
	     | statement result |
	     statement := Statements at: ''{3}''.
	     result := statement query: {2}. 
	
	     ^result.
	    '
				format:
					{methodNameMaybeParams.
					executeParams.
					methodNames}.
			Transcript show: methodString.
			self compile: methodString classified: 'accessor' ]
]

{ #category : #initialization }
HeySql class >> generateSqlStatement: methodName sql: sql [
	"Add an server side compiled statment which can be access from a slot"

	| statement |
	statement := Client prepare: sql.
	Statements at: methodName put: statement.
]

{ #category : #initialization }
HeySql class >> generatereSimpleDbOperations [
	"Generate helpers for getting by id, inserting, updating and deleting"

]

{ #category : #initialization }
HeySql class >> setDbFields: allFields [ 
	"Set fields which also have column in database"
	| fields |
	fields := allFields splitOn: ' '.
	DbFields := fields.
]

{ #category : #accessor }
HeySql >> id [ 
	    "Autogenerated HeySql getter"
	    ^id.
	  
]

{ #category : #accessor }
HeySql >> id: x [  
	    "Autogenerated HeySql setter"
	    id := x.
	  
]

{ #category : #documenting }
HeySql >> notes [
	" myDict keysAndValuesDo: [ :key :value | value doSomething ].
	Dictionary newFrom: {1 -> 7. 2 -> 3. 3 -> 1. 4 -> 3}
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	(Smalltalk classNamed: clsName) methodName: arg. (maybe param, but check more params) 
	
	Transcript show: o class asString.
	
	'HeySql' asClass .
	
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	5 perform: ('factorial' asSymbol ) og 4 perform: #max: withArguments
	
!! Encode

x := (ZnCharacterEncoder newForEncoding: 'utf8')
      encodeString: 'Les élèves Français'.

(ZnCharacterEncoder newForEncoding: 'utf8') decodeBytes: x		
	
	"
	

	

	<wikiStyleHelp: #'The name of the book I want to write'>
	
]
