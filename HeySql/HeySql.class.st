"
Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:

For the Class part:  State a one line summary. For example, ""I represent a paragraph of text"".

For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.

For the Collaborators Part: State my main collaborators and one line about how I interact with them. 

Public API and Key Messages

- message one   
- message two 
- (for bonus points) how to create instances.

   One simple example is simply gorgeous.
OK
 
Internal Representation and Key Implementation Points.

    Instance Variables
	db_x:		<Object>
	db_y:		<Object>


    Implementation Points
"
Class {
	#name : #HeySql,
	#superclass : #Object,
	#instVars : [
		'id'
	],
	#classVars : [
		'Client',
		'DbFields',
		'Statements'
	],
	#category : #'HeySql-Initialize'
}

{ #category : #adding }
HeySql class >> addDependencies [
	"This load dependencies which are needed for the package to work"
	Metacello new
 	  baseline: 'P3';
	   repository: 'github://svenvc/P3';
	   load.
]

{ #category : #connection }
HeySql class >> connect: client [
	"First connect through p3 as usual, and pass the client on to this class. Reuse client if allready set"
	Client := client.
	client ifNil: [ Client := client ]
]

{ #category : #initialization }
HeySql class >> findNumberOfParams: sql [
	"Iterates over a P3-executable and finds number of sql-params, namely those who starts with $"
		| s |
	s := Set new.
	sql regex: '[$]\d+' matchesCollect: [ :r |
	s add: r].
	^ (s size)
]

{ #category : #accesing }
HeySql class >> generateGettersAndSetters [
	"Generete getters and setters for all db-fields"

	DbFields
		do: [ :field | 
			| getter setter |
			getter := '
	    {1} 
	    "Autogenerated HeySql getter"
	    ^{1}.
	  ' format: {field}.
			setter := '
	    {1}: x  
	    "Autogenerated HeySql setter"
	    {1} := x.
	  ' format: {field}.
			self  compile: getter classified: 'accessor'.
			self  compile: setter classified: 'accessor' ]
]

{ #category : #initialization }
HeySql class >> generateSqlMethods: dict [
	"Iterating over all key-value elements in a dictionary and creates methods based on these. It is based on P3-postgres syntax.
	 sql-functions with parameter need to be declared ending with colon, like always in smalltalk "

	"Example: 
	
	d := Dictionary newFrom: 
	{ 'allBooks' -> 'select * from books' . 
  	  'allCustomerWithMoreThanOnePurches' -> 'select, join and have sql-fun here' 
	  'queryWithTwoParams' -> 'select something where x = $1 and y = $2 ]  '
	}. 
	
	"

	Statements := Dictionary new.
	dict
		keysAndValuesDo: [ :methodName :sql | 
			"self class compile: methodString classified: 'heysql' ]"
			| methodString num params methodNameMaybeParams |
			
			self generateSqlStatement: methodName sql: sql.
			num := self findNumberOfParams: sql.
			methodNameMaybeParams := num > 0
				ifTrue: methodName , ':'
				ifFalse: methodName.
			params := num > 0
				ifTrue: [ ((Interval from: 1 to: num) collect: [ :v | 'p' , v asString ])
						joinUsing: ' ' ]
				ifFalse: [ '' ].
			methodString := '
	     {1} {2}
	     "Autogenerated heysql-method"
	     ^{1}.
	    '
				format:
					{methodNameMaybeParams.
					params}.
			Transcript show: methodString ]
]

{ #category : #initialization }
HeySql class >> generateSqlStatement: methodName sql: sql [
	"Add an server side compiled statment which can be access from a slot"

	| statement |
	statement := Client prepare: sql.
	Statements at: methodName put: statement.
	Statements inspect
]

{ #category : #initialization }
HeySql class >> setDbFields: allFields [ 
	"Set fields which also have column in database"
	| fields |
	fields := allFields splitOn: ' '.
	DbFields := fields.
]

{ #category : #accessor }
HeySql >> id [ 
	    "Autogenerated HeySql getter"
	    ^id.
	  
]

{ #category : #accessor }
HeySql >> id: x [  
	    "Autogenerated HeySql setter"
	    id := x.
	  
]

{ #category : #documenting }
HeySql >> notes [
<wikiStyleHelp: #'The name of the book I want to write'>
	" myDict keysAndValuesDo: [ :key :value | value doSomething ].
	Dictionary newFrom: {1 -> 7. 2 -> 3. 3 -> 1. 4 -> 3}
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	(Smalltalk classNamed: clsName) methodName: arg. (maybe param, but check more params) 
	
	Transcript show: o class asString.
	
	'HeySql' asClass .
	
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	5 perform: ('factorial' asSymbol ) og 4 perform: #max: withArguments
	
	"
]
