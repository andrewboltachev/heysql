"
Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:

For the Class part:  State a one line summary. For example, ""I represent a paragraph of text"".

For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.

For the Collaborators Part: State my main collaborators and one line about how I interact with them. 

Public API and Key Messages

- message one   
- message two 
- (for bonus points) how to create instances.

   One simple example is simply gorgeous.
OK
 
Internal Representation and Key Implementation Points.

    Instance Variables
	db_x:		<Object>
	db_y:		<Object>


    Implementation Points
"
Class {
	#name : #HeySql,
	#superclass : #Object,
	#instVars : [
		'id'
	],
	#classVars : [
		'Client',
		'DbFields'
	],
	#category : #'HeySql-Initialize'
}

{ #category : #adding }
HeySql class >> addDependencies [
	"This load dependencies which are needed for the package to work"
	Metacello new
 	  baseline: 'P3';
	   repository: 'github://svenvc/P3';
	   load.
]

{ #category : #connection }
HeySql class >> connect: client [
	"First connect through p3 as usual, and pass the client on to this class. Reuse client if allready set"	
	client ifNil: [ Client := client ]
]

{ #category : #initialization }
HeySql >> addSqlMethods: dict [
	"Iterating over all key-value elements in a dictionary and creates methods based on these. It is based on P3-postgres syntax.
	 sql-functions with parameter need to be declared ending with colong, like always in smalltalk "
	"Example: 
	
	d := Dictionary newFrom: 
	{ 'allBooks' -> 'select * from books' . 
  	  'allCustomerWithMoreThanOnePurches' -> 'select, join and have sql-fun here' 
	  'queryWithTwoParams' -> 'select something where x = {1} and y = {2} ]  '
	}. 
	
	"			
	
   dict keysAndValuesDo: [ :methodName :v | | methodString |  
	   methodString := '
	     {1} 
	     "Autogenerated heysql-method"
	     ^{1}.
	    ' format: { methodName }.
	   self class compile: methodString classified: 'accessor'.
	]
]

{ #category : #accesing }
HeySql >> generateGettersAndSetters [
	"Generete getters and setters for all db-fields"
	DbFields do:
	[ :field | | getter setter |
	  getter := '
	    {1} 
	    "Autogenerated HeySql getter"
	    ^{1}.
	  ' format: { field }.
	  setter := '
	    {1}: x  
	    "Autogenerated HeySql setter"
	    {1} := x.
	  ' format: { field }.
	  self class compile: getter classified: 'accessor'.
	  self class compile: setter classified: 'accessor'
	]. 
	
]

{ #category : #accessor }
HeySql >> id [ 
	    "Autogenerated HeySql getter"
	    ^id.
	  
]

{ #category : #accessor }
HeySql >> id: x [  
	    "Autogenerated HeySql setter"
	    id := x.
	  
]

{ #category : #documenting }
HeySql >> notes [
<wikiStyleHelp: #'The name of the book I want to write'>
	" myDict keysAndValuesDo: [ :key :value | value doSomething ].
	Dictionary newFrom: {1 -> 7. 2 -> 3. 3 -> 1. 4 -> 3}
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	(Smalltalk classNamed: clsName) methodName: arg. (maybe param, but check more params) 
	
	Transcript show: o class asString.
	
	'HeySql' asClass .
	
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	5 perform: ('factorial' asSymbol ) og 4 perform: #max: withArguments
	
	"
]

{ #category : #initialization }
HeySql >> setDbFields: allFields [ 
	"Set fields which also have column in database"
	| fields |
	fields := allFields splitOn: ' '.
	DbFields := fields.
]
